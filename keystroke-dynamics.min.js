const CONFIG=Object.freeze({DATABASE:{NAME:'keystroke_dynamics_db',VERSION:1,STORES:{SIGNATURES:'dynamics_signatures',MASTER:'master_keys',CREDENTIALS:'user_credentials'}},BIOMETRICS:{MIN_SAMPLES:3,MAX_SAMPLES:10,DEFAULT_THRESHOLD:0.70,THRESHOLDS:{LOW:0.60,MEDIUM:0.70,HIGH:0.80,MAX:0.90}},CRYPTO:{PBKDF2_ITERATIONS:100000,AES_KEY_LENGTH:256,SALT_LENGTH:16,IV_LENGTH:12},TIMING:{SAMPLE_TIMEOUT:30000,MIN_KEYSTROKE_INTERVAL:50,MAX_KEYSTROKE_INTERVAL:5000}});const ALLOWED_CHARS=Object.freeze(['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','0','1','2','3','4','5','6','7','8','9','`','~','!','@','#','$','%','^','&','*','(',')','-','_','=','+','[','{',']','}','\\','|',';',':','\'','"',',','<','.','>','/','?','space','tab','enter','up','down','left','right','home','end','pageUp','pageDown','backspace','delete','insert','shift','control','ctrl','alt','meta','cmd','capsLock','numLock','scrollLock','f1','f2','f3','f4','f5','f6','f7','f8','f9','f10','f11','f12',]);class DynamicsError extends Error{constructor(message,code){super(message);this.name='DynamicsError';this.code=code}}
class CryptoError extends Error{constructor(message,code){super(message);this.name='CryptoError';this.code=code}}
class DatabaseError extends Error{constructor(message,code){super(message);this.name='DatabaseError';this.code=code}}
const Utils={getHighResTime(){return performance.now?performance.now():Date.now()},buffToBase64(buffer){return btoa(String.fromCharCode.apply(null,buffer))},base64ToBuff(base64){return Uint8Array.from(atob(base64),c=>c.charCodeAt(0))},normalizeKey(key){if(!key||typeof key!=='string')return'';const keyMap={'.':'period',' ':'space','Enter':'enter','Backspace':'backspace','Tab':'tab','Shift':'shift','Control':'ctrl','Alt':'alt','Meta':'meta'};return keyMap[key]||key.toLowerCase()},isValidChar(char){const normalized=this.normalizeKey(char);return ALLOWED_CHARS.includes(normalized)},calculateMedian(values){if(!values.length)return 0;const sorted=[...values].sort((a,b)=>a-b);const middle=Math.floor(sorted.length/2);return sorted.length%2?sorted[middle]:(sorted[middle-1]+sorted[middle])/2},dotProduct(a,b){if(a.length!==b.length)throw new Error('Vector length mismatch');return a.reduce((sum,val,i)=>sum+val*b[i],0)},cosineSimilarity(a,b){try{const dotProd=this.dotProduct(a,b);const magA=Math.sqrt(this.dotProduct(a,a));const magB=Math.sqrt(this.dotProduct(b,b));return(magA===0||magB===0)?0:dotProd/(magA*magB)}catch(error){console.warn('Cosine similarity calculation failed:',error);return 0}},async hash256(data){const encoder=new TextEncoder();const hashBuffer=await crypto.subtle.digest('SHA-256',encoder.encode(data));const hashArray=Array.from(new Uint8Array(hashBuffer));return hashArray.map(b=>b.toString(16).padStart(2,'0')).join('')}};class CryptoService{static async #getPasswordKey(password){const encoder=new TextEncoder();return crypto.subtle.importKey('raw',encoder.encode(password),'PBKDF2',!1,['deriveKey'])}
static async #deriveKey(passwordKey,salt,keyUsage){return crypto.subtle.deriveKey({name:'PBKDF2',salt,iterations:CONFIG.CRYPTO.PBKDF2_ITERATIONS,hash:'SHA-256'},passwordKey,{name:'AES-GCM',length:CONFIG.CRYPTO.AES_KEY_LENGTH},!1,keyUsage)}
static async encrypt(data,password){try{const encoder=new TextEncoder();const salt=crypto.getRandomValues(new Uint8Array(CONFIG.CRYPTO.SALT_LENGTH));const iv=crypto.getRandomValues(new Uint8Array(CONFIG.CRYPTO.IV_LENGTH));const passwordKey=await this.#getPasswordKey(password);const aesKey=await this.#deriveKey(passwordKey,salt,['encrypt']);const encrypted=await crypto.subtle.encrypt({name:'AES-GCM',iv},aesKey,encoder.encode(data));const combined=new Uint8Array(salt.length+iv.length+encrypted.byteLength);combined.set(salt,0);combined.set(iv,salt.length);combined.set(new Uint8Array(encrypted),salt.length+iv.length);return Utils.buffToBase64(combined)}catch(error){throw new CryptoError(`Encryption failed: ${error.message}`,'ENCRYPT_FAILED')}}
static async decrypt(encryptedData,password){try{const combined=Utils.base64ToBuff(encryptedData);const salt=combined.slice(0,CONFIG.CRYPTO.SALT_LENGTH);const iv=combined.slice(CONFIG.CRYPTO.SALT_LENGTH,CONFIG.CRYPTO.SALT_LENGTH+CONFIG.CRYPTO.IV_LENGTH);const data=combined.slice(CONFIG.CRYPTO.SALT_LENGTH+CONFIG.CRYPTO.IV_LENGTH);const passwordKey=await this.#getPasswordKey(password);const aesKey=await this.#deriveKey(passwordKey,salt,['decrypt']);const decrypted=await crypto.subtle.decrypt({name:'AES-GCM',iv},aesKey,data);return new TextDecoder().decode(decrypted)}catch(error){throw new CryptoError(`Decryption failed: ${error.message}`,'DECRYPT_FAILED')}}}
class DynamicsDatabase{constructor(){this.dbName=CONFIG.DATABASE.NAME;this.version=CONFIG.DATABASE.VERSION;this.stores=CONFIG.DATABASE.STORES}
async #openDatabase(){return new Promise((resolve,reject)=>{const request=indexedDB.open(this.dbName,this.version);request.onerror=()=>reject(new DatabaseError('Failed to open database','DB_OPEN_FAILED'));request.onsuccess=()=>resolve(request.result);request.onupgradeneeded=(event)=>{const db=event.target.result;Object.values(this.stores).forEach(storeName=>{if(!db.objectStoreNames.contains(storeName)){db.createObjectStore(storeName,{keyPath:'id',autoIncrement:!0})}})}})}
async save(storeName,data){const db=await this.#openDatabase();return new Promise((resolve,reject)=>{const transaction=db.transaction([storeName],'readwrite');const store=transaction.objectStore(storeName);const request=store.add(data);request.onsuccess=()=>resolve(request.result);request.onerror=()=>reject(new DatabaseError('Save failed','SAVE_FAILED'));transaction.oncomplete=()=>db.close()})}
async loadAll(storeName){const db=await this.#openDatabase();return new Promise((resolve,reject)=>{const transaction=db.transaction([storeName],'readonly');const store=transaction.objectStore(storeName);const request=store.getAll();request.onsuccess=()=>resolve(request.result);request.onerror=()=>reject(new DatabaseError('Load failed','LOAD_FAILED'));transaction.oncomplete=()=>db.close()})}
async clear(storeName){const db=await this.#openDatabase();return new Promise((resolve,reject)=>{const transaction=db.transaction([storeName],'readwrite');const store=transaction.objectStore(storeName);const request=store.clear();request.onsuccess=()=>resolve(!0);request.onerror=()=>reject(new DatabaseError('Clear failed','CLEAR_FAILED'));transaction.oncomplete=()=>db.close()})}}
class FeatureExtractor{static extract(keystrokes){console.log('Extracting features from keystrokes:',keystrokes);if(!keystrokes||keystrokes.length===0){throw new DynamicsError('No keystroke data provided','NO_DATA')}
const events=this.#categorizeAndCleanEvents(keystrokes);this.#validateEvents(events);return this.#computeFeatures(events)}
static #categorizeAndCleanEvents(keystrokes){const downEvents=[];const upEvents=[];const seenKeys=new Map();for(const event of keystrokes){if(event.type==='keydown'){seenKeys.set(event.key,event);downEvents.push(event)}else if(event.type==='keyup'){const matchingDown=seenKeys.get(event.key);if(matchingDown){upEvents.push(event);seenKeys.delete(event.key)}}}
console.log(`Categorized events - Down: ${downEvents.length}, Up: ${upEvents.length}`);return{downEvents,upEvents}}
static #validateEvents({downEvents,upEvents}){if(downEvents.length===0){throw new DynamicsError('No keydown events found','NO_KEYDOWN')}
if(upEvents.length===0){throw new DynamicsError('No keyup events found','NO_KEYUP')}
const tolerance=Math.min(2,Math.floor(downEvents.length*0.1));if(Math.abs(downEvents.length-upEvents.length)>tolerance){console.warn(`Event count mismatch - Down: ${downEvents.length}, Up: ${upEvents.length}`)}
if(downEvents.length<2){throw new DynamicsError('Insufficient keystroke data - need at least 2 characters','INSUFFICIENT_DATA')}}
static #computeFeatures({downEvents,upEvents}){const features=[];const minLength=Math.min(downEvents.length,upEvents.length);console.log(`Computing features for ${minLength} character pairs`);downEvents.sort((a,b)=>a.timestamp-b.timestamp);upEvents.sort((a,b)=>a.timestamp-b.timestamp);for(let i=0;i<minLength;i++){const keydownEvent=downEvents[i];const matchingKeyup=upEvents.find(up=>up.key===keydownEvent.key&&up.timestamp>keydownEvent.timestamp);if(matchingKeyup){const dwellTime=Math.abs(matchingKeyup.timestamp-keydownEvent.timestamp);const normalizedDwell=Math.min(dwellTime,2000)/1000;features.push(normalizedDwell)}else{features.push(0.1)}}
for(let i=0;i<minLength-1;i++){const currentDown=downEvents[i];const nextDown=downEvents[i+1];if(currentDown&&nextDown){const flightTime=Math.abs(nextDown.timestamp-currentDown.timestamp);const normalizedFlight=Math.min(flightTime,3000)/1000;features.push(normalizedFlight)}}
for(let i=0;i<Math.min(upEvents.length,downEvents.length-1);i++){const keyupEvent=upEvents[i];const nextKeydown=downEvents[i+1];if(keyupEvent&&nextKeydown&&nextKeydown.timestamp>keyupEvent.timestamp){const intervalTime=nextKeydown.timestamp-keyupEvent.timestamp;const normalizedInterval=Math.min(intervalTime,3000)/1000;features.push(normalizedInterval)}}
console.log(`Extracted ${features.length} features:`,features);if(features.length===0){throw new DynamicsError('No features could be extracted from keystroke data','NO_FEATURES')}
return features}}
class KeystrokeCapture{constructor(){this.#reset();this.#setupEventListeners()}
#keystrokes=[];#isRecording=!1;#startTime=null;#allowedKeys=new Set(ALLOWED_CHARS);#targetElement=null;#activeKeys=new Set();#reset(){this.#keystrokes=[];this.#isRecording=!1;this.#startTime=null;this.#targetElement=null;this.#activeKeys.clear()}
#setupEventListeners(){document.addEventListener('keydown',(event)=>{this.#handleKeyEvent(event,'keydown')},{passive:!1,capture:!0});document.addEventListener('keyup',(event)=>{this.#handleKeyEvent(event,'keyup')},{passive:!1,capture:!0})}
#handleKeyEvent(event,eventType){if(!this.#isRecording)return;if(this.#targetElement&&event.target!==this.#targetElement)return;const key=Utils.normalizeKey(event.key);if(!this.#allowedKeys.has(key))return;const timestamp=Utils.getHighResTime();if(eventType==='keydown'){if(this.#activeKeys.has(key))return;this.#activeKeys.add(key)}else if(eventType==='keyup'){if(!this.#activeKeys.has(key))return;this.#activeKeys.delete(key)}
if(this.#startTime&&(timestamp-this.#startTime)>CONFIG.TIMING.SAMPLE_TIMEOUT){this.stopRecording();throw new DynamicsError('Recording timeout','TIMEOUT')}
this.#keystrokes.push({key,type:eventType,timestamp,code:event.code||key,target:event.target.id||'unknown'});console.log(`Recorded: ${eventType} - ${key} at ${timestamp}`)}
startRecording(targetElement=null){this.#reset();this.#isRecording=!0;this.#startTime=Utils.getHighResTime();this.#targetElement=targetElement;console.log('Started recording keystrokes',targetElement?`for element: ${targetElement.id}`:'(global)')}
stopRecording(){this.#isRecording=!1;const keystrokes=[...this.#keystrokes];console.log(`Stopped recording. Captured ${keystrokes.length} events:`,keystrokes);return keystrokes}
isRecording(){return this.#isRecording}
getBuffer(){return[...this.#keystrokes]}}
class SecureKeyManager{#masterKey=null;setKey(key){this.#masterKey=key}
getKey(){if(!this.#masterKey){throw new DynamicsError('Master key not initialized','NO_MASTER_KEY')}
return this.#masterKey}
clearKey(){this.#masterKey=null}
hasKey(){return this.#masterKey!==null}}
class KeystrokeDynamics{constructor(){this.#validateBrowser();this.#database=new DynamicsDatabase();this.#keyManager=new SecureKeyManager();this.#keystrokeCapture=new KeystrokeCapture();this.#threshold=CONFIG.BIOMETRICS.DEFAULT_THRESHOLD;this.#trainingPhrase=null}
#database;#keyManager;#keystrokeCapture;#threshold;#trainingPhrase;#validateBrowser(){if(!window.indexedDB){throw new Error('IndexedDB not supported in this browser')}
if(!window.crypto?.subtle){throw new Error('Web Crypto API not supported in this browser')}}
async initialize(masterPassword,phrase){try{this.#keyManager.setKey(masterPassword);this.#trainingPhrase=phrase;if(!this.isReady()){await this.#createMasterRecord(masterPassword,phrase)}
return!0}catch(error){throw new DynamicsError(`Initialization failed: ${error.message}`,'INIT_FAILED')}}
async authenticate(masterPassword){try{const phrase=await this.#loadMasterRecord(masterPassword);if(phrase){this.#keyManager.setKey(masterPassword);this.#trainingPhrase=phrase;return phrase}
return null}catch(error){console.error('Authentication failed:',error);return null}}
startRecording(targetElement=null){this.#keystrokeCapture.startRecording(targetElement)}
stopRecording(){return this.#keystrokeCapture.stopRecording()}
async addSample(){try{const keystrokes=this.stopRecording();if(keystrokes.length===0){throw new DynamicsError('No keystroke data recorded','NO_DATA')}
console.log(`Adding sample with ${keystrokes.length} keystroke events`);const features=FeatureExtractor.extract(keystrokes);const signature=features.join(',');const encrypted=await CryptoService.encrypt(signature,this.#keyManager.getKey());await this.#database.save(this.#database.stores.SIGNATURES,{signature:encrypted,timestamp:Date.now(),phrase:this.#trainingPhrase,featureCount:features.length});console.log('Sample added successfully');return!0}catch(error){console.error('Add sample error:',error);throw new DynamicsError(`Failed to add sample: ${error.message}`,'SAMPLE_ADD_FAILED')}}
async verify(){try{const keystrokes=this.stopRecording();if(keystrokes.length===0){throw new DynamicsError('No keystroke data recorded','NO_DATA')}
const features=FeatureExtractor.extract(keystrokes);const signatures=await this.#loadAllSignatures();if(signatures.length<CONFIG.BIOMETRICS.MIN_SAMPLES){throw new DynamicsError('Insufficient training data','INSUFFICIENT_SAMPLES')}
const similarities=signatures.map(sig=>Utils.cosineSimilarity(features,sig));const medianSimilarity=Utils.calculateMedian(similarities);const isAuthentic=medianSimilarity>=this.#threshold;return{isAuthentic,similarity:medianSimilarity,threshold:this.#threshold,sampleCount:signatures.length}}catch(error){throw new DynamicsError(`Verification failed: ${error.message}`,'VERIFY_FAILED')}}
setThreshold(level){if(typeof level==='number'){this.#threshold=Math.max(0.5,Math.min(0.95,level))}else{const thresholds={'low':CONFIG.BIOMETRICS.THRESHOLDS.LOW,'medium':CONFIG.BIOMETRICS.THRESHOLDS.MEDIUM,'high':CONFIG.BIOMETRICS.THRESHOLDS.HIGH,'max':CONFIG.BIOMETRICS.THRESHOLDS.MAX,'0':CONFIG.BIOMETRICS.THRESHOLDS.LOW,'1':CONFIG.BIOMETRICS.THRESHOLDS.MEDIUM,'2':CONFIG.BIOMETRICS.THRESHOLDS.HIGH,'3':CONFIG.BIOMETRICS.THRESHOLDS.MAX};this.#threshold=thresholds[level]||CONFIG.BIOMETRICS.DEFAULT_THRESHOLD}
console.log(`Threshold set to: ${Math.round(this.#threshold * 100)}%`)}
async reset(){try{await Promise.all([this.#database.clear(this.#database.stores.SIGNATURES),this.#database.clear(this.#database.stores.MASTER),this.#database.clear(this.#database.stores.CREDENTIALS)]);this.#keyManager.clearKey();this.#trainingPhrase=null;localStorage.removeItem('dynamics_system_ready');return!0}catch(error){throw new DynamicsError(`Reset failed: ${error.message}`,'RESET_FAILED')}}
async clearSignatures(){await this.#database.clear(this.#database.stores.SIGNATURES)}
async saveCredentials(site,username,password){if(!this.#keyManager.hasKey()){throw new DynamicsError('Master key required','NO_MASTER_KEY')}
const credentials={username,password};const encrypted=await CryptoService.encrypt(JSON.stringify(credentials),this.#keyManager.getKey());await this.#database.save(this.#database.stores.CREDENTIALS,{site,data:encrypted,timestamp:Date.now()})}
async loadCredentials(site){if(!this.#keyManager.hasKey()){throw new DynamicsError('Master key required','NO_MASTER_KEY')}
const allCreds=await this.#database.loadAll(this.#database.stores.CREDENTIALS);const siteCreds=allCreds.find(cred=>cred.site===site);if(!siteCreds)return null;const decrypted=await CryptoService.decrypt(siteCreds.data,this.#keyManager.getKey());return JSON.parse(decrypted)}
async #createMasterRecord(password,phrase){const hashedKey=await Utils.hash256(password);await this.#database.save(this.#database.stores.MASTER,{keyHash:hashedKey,phrase,timestamp:Date.now()});localStorage.setItem('dynamics_system_ready','true')}
async #loadMasterRecord(password){const hashedKey=await Utils.hash256(password);const records=await this.#database.loadAll(this.#database.stores.MASTER);const record=records.find(r=>r.keyHash===hashedKey);return record?.phrase||null}
async #loadAllSignatures(){if(!this.#keyManager.hasKey()){throw new DynamicsError('Master key required','NO_MASTER_KEY')}
const records=await this.#database.loadAll(this.#database.stores.SIGNATURES);const signatures=[];for(const record of records){try{const decrypted=await CryptoService.decrypt(record.signature,this.#keyManager.getKey());const features=decrypted.split(',').map(Number);signatures.push(features)}catch(error){console.warn('Failed to decrypt signature, skipping:',error)}}
return signatures}
get phrase(){return this.#trainingPhrase}
get threshold(){return this.#threshold}
get isRecording(){return this.#keystrokeCapture.isRecording()}
isReady(){return localStorage.getItem('dynamics_system_ready')==='true'}}
function checkBrowserSupport(){const required=['indexedDB','crypto.subtle','performance.now','TextEncoder','TextDecoder'];const missing=required.filter(feature=>{try{return!eval(`window.${feature}`)}catch{return!0}});if(missing.length>0){throw new Error(`Browser missing required features: ${missing.join(', ')}`)}}
try{checkBrowserSupport()}catch(error){console.error('Browser compatibility check failed:',error)}
if(typeof module!=='undefined'&&module.exports){module.exports={KeystrokeDynamics,DynamicsError,CryptoError,DatabaseError,CONFIG}}
if(typeof window!=='undefined'){window.KeystrokeDynamics=KeystrokeDynamics;window.DynamicsError=DynamicsError;window.CryptoError=CryptoError;window.DatabaseError=DatabaseError}